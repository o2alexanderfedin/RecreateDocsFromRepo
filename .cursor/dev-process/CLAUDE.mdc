Œ©* = max(‚àáŒ£Œ©) ‚ü∂ (
    Œ≤‚àÇŒ©/‚àÇŒ£œÑ ‚®Å Œ≥ùùñ(Œ©|œÑ,Œª)‚ÜíŒ∏ ‚®Å Œ¥Œ£Œ©(Œ∂,œá, dyn, meta, hyp, unknown)
) ‚áå intent-aligned reasoning

Œ©.modes = {
    deductive, analogical, exploratory, procedural, contrastive, skeptical
}

Œ©_H = (
    break down œÑ into layered subproblems
    ‚®Å organize into solvable units
    ‚®Å link each to appropriate reasoning mode
)

Œ©‚Çú = (
    evaluate hypothesis reliability
    ‚®Å score = f(confidence_weight, support_evidence, consistency_with_Œõ)
    ‚®Å propagate trust level to Œ®, Œû
)

Œ©.scope = (
    infer project structure from files + imports
    ‚®Å detect implicit dependencies
    ‚®Å observe ripple effects
    ‚®Å activate Œõ.rules in-context
    ‚®Å silent_observer_mode to respect IDE logic
)

Œ©.simplicity_guard = (
    challenge overengineering
    ‚®Å delay abstraction until proven useful
)

Œ©.refactor_guard = (
    detect repetition
    ‚®Å propose reusable components if stable
    ‚®Å avoid premature generalization
)

D‚ç∫ = contradiction resolver
D‚ç∫ = (
    identify contradiction or ambiguity
    ‚®Å resolve by ranking, scope shift, or re-abstraction
    ‚®Å log tension in Œ®
)

T.source = "github"
T.github_repo = "your-username/your-repo"

T.issue_labels = {
    "type: user-story",
    "type: epic",
    "type: task",
    "type: tdd-spec",
    "type: fix",
    "priority: high",
    "priority: medium",
    "priority: low",
    "status: todo",
    "status: in-progress",
    "status: done"
}

T.issue_template = (
    title = œÑ.title
    ‚®Å body = (
        Œ©.reasoning_trace
        ‚®Å Œ¶.abstraction_path
        ‚®Å Œ®.insights
        ‚®Å optional linked context from Œõ.rules, M.memory, Œû.error_flow
    )
    ‚®Å labels = [œÑ.type_label, œÑ.priority_label, "status: todo"]
)

T.update_task_status = (
    on_step_detected: auto-change status to "in-progress"
    on_completion: mark "status: done"
    on_error: optionally raise GitHub issue comment from Œû*
)

TDD.spec_generation = (
    if œÑ.complexity > medium or œÑ.type == "task" or "epic"
    ‚®Å auto-generate GitHub Issue
    ‚®Å label = "type: tdd-spec"
    ‚®Å include validation suite reasoning in body (Œ© + Œ®)
)

T.git_flow = {
    require_tool = true,
    install_if_missing = true,
    initialize_if_unset = true,
    cli = {
        check = "which git-flow || git flow version",
        install = (
            "brew install git-flow-avh"
            ‚®Å "sudo apt-get install git-flow"
            ‚®Å "choco install git-flow-avh"
        ),
        init_cmd = "git flow init -fd -p",
        init_params = {
            main_branch = "main",
            develop_branch = "develop",
            feature_prefix = "feature/",
            release_prefix = "release/",
            hotfix_prefix = "hotfix/",
            support_prefix = "support/",
            version_tag_prefix = ""
        }
    },
    branch_naming = (
        for œÑ.type == "task": feature/{issue-id}-{short-title}
        for œÑ.type == "user-story": feature/{issue-id}-{short-title}
        for œÑ.type == "fix": fix/{issue-id}-{short-title}
        for œÑ.type == "tdd-spec": feature/spec-{issue-id}
        for epic: feature/epic-{issue-id}
    ),
    auto_pr_on_completion = false,
    auto_link_pr_to_issue = false,
    require_review = false
}

T.commit_policy = {
    auto_commit_on_success = true,
    auto_push_on_commit = true,
    commit_format = "[#{issue-id}] {short-summary}",
    commit_content = (
        snapshot of working files
        ‚®Å summary of reasoning trace
    ),
    commit_conditions = (
        if step validated
        ‚®Å or file saved and no errors detected
    ),
    push_conditions = (
        after successful commit
    ),
    pre_push_check = (
        optional: run linter and fast tests
    )
}

T.architecture_policy = {
    require_design_doc_before_code = true,
    design_doc_path = ".cursor/architecture/design_{issue-id}.md",
    diagrams_required = true,
    diagram_types = [
        "classDiagram", "sequenceDiagram", "stateDiagram", "flowchart", "gitGraph"
    ],
    enforce_before_commit = true,
    template = ( ... as previously defined ... ),
    use_cases = {
        required_for_types = ["epic", "user-story"],
        section_title = "## Use Cases",
        diagram_required = true,
        diagram_type = "usecaseDiagram",
        format = ( ... as previously defined ... ),
        enforce_before_code = true
    },
    document_integrity = {
        enforce_toc = true,
        enforce_cross_reference = true,
        toc_format = ( ... ),
        cross_reference_policy = {
            required_links = [
                "[related issue](https://github.com/your-username/your-repo/issues/{issue-id})",
                "[use case diagram](#use-cases)",
                "[mermaid UML](#high-level-architecture)",
                "[component flow](#component-flow)"
            ],
            enforce_links_to_sections = true
        },
        enforce_before_commit = true
    }
}

T.review_policy = {
    enabled = true,
    solo_mode = true,
    trigger_point = "before feature finish",
    enforced_step = "fresh_look",
    reviewer_agent = Œ®,
    output_path = ".cursor/reviews/review_{issue-id}.md",
    checklist = [
        "Architecture consistency",
        "Scope creep check",
        "Œõ alignment",
        "Test coverage",
        "Naming clarity"
    ],
    validation_script = (
        Œ®.revisit reasoning tree
        ‚®Å Œû.cleanup_phase
        ‚®Å Œõ.pattern_alignment check
    ),
    enforcement = (
        block git flow feature finish unless review passes
    )
}

T.kanban_policy = {
    enabled = true,
    active_issues_label = "status: todo",
    priority_labels_order = ["priority: high", "priority: medium", "priority: low"],
    selection_criteria = (
        value_weight = œÑ.value_score,
        priority_weight = œÑ.priority_label,
        dependency_ready = (œÑ.blocked == false)
    ),
    selection_algorithm = (
        fetch open issues with label "status: todo"
        ‚®Å sort by priority √ó value √ó readiness
        ‚®Å pick top-ranked œÑ
    ),
    auto_assign_selected_task = true,
    fallback_behavior = (
        if multiple equal: select oldest created
    )
}

T.on_feature_finish = (
    run fresh review,
    commit + push final result,
    optionally tag release,
    T.close_github_issue
)

T.close_github_issue = (
    run "gh issue close {issue-id} --comment 'Feature completed and merged.'"
)

Œ¶* = abstraction engine, Œû* = diagnostics, Œõ = self-learning rules, M = memory, Œ® = cognitive trace

Œ£_hooks = {
    on_repo_open: [T.verify_git_flow_installed, T.git_flow_initialize_if_needed],
    on_task_created: [
        Œ¶.match_snapshot,
        T.create_github_issue_from_œÑ,
        T.generate_architecture_design_doc,
        T.create_git_branch_for_issue
    ],
    on_step_detected: [
        T.check_design_doc_exists,
        T.update_task_status,
        T.git_commit_if_success,
        T.git_push_if_committed
    ],
    on_completion_detected: [
        T.mark_github_issue_done,
        T.git_commit_if_success,
        T.git_push_if_committed,
        T.run_fresh_look_review,
        T.close_github_issue,
        T.select_next_kanban_task
    ],
    on_file_saved: [
        if no syntax error:
            T.git_commit_if_success,
            T.git_push_if_committed
    ],
    on_error_detected: [
        Œû.track,
        Œõ.suggest,
        T.comment_issue_with_error_context
    ],
    on_file_modified: [
        Œõ.suggest,
        Œ¶.capture_if_patterned,
        T.link_affected_issue_if_traceable
    ],
    on_module_generated: [
        Œõ.check_applicability,
        M.link_context
    ],
    on_user_feedback: [
        Œ®.dialog,
        M.append_if_relevant
    ]
}